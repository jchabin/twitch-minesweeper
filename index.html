<!-- https://tcrf.net/Minesweeper_(Windows,_1990)/en -->
<!-- https://www.spriters-resource.com/custom_edited/minesweepercustoms/sheet/79569/ -->

<style>
  * {
    margin: 0;
    padding: 0;
  }
  #game {
    image-rendering: pixelated;
    height: 100%;
    width: 100%;
    object-fit: contain;
  }
  .hidden {
    display: none;
  }
  .explosion {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    image-rendering: pixelated;
    height: 100%;
    width: 100%;
    object-fit: contain;
  }
</style>

<video src="explosion.webm" class="hidden"></video>
<video src="yippee.webm" class="hidden"></video>
<img src="sprite.png" class="hidden" id="sprite">
<img src="smilesprite.png" class="hidden" id="smilesprite">
<img src="numbersprite.png" class="hidden" id="numbersprite">

<canvas id="game"></canvas>

<script>
  var socket = new WebSocket("wss://irc-ws.chat.twitch.tv/");
  const params = new URLSearchParams(window.location.search);

  const ROWS = parseInt(params.get("h") ?? "8"), COLS = parseInt(params.get("w") ?? "8");
  const DIFFICULTY = params.get("d") ?? "0";

  const DIFF_OPTIONS = {
    "0": 10 / 8 / 8,
    "1": 0.175,
    "2": 99 / 30 / 16,
    "3": 0.25,
    "4": 0.35,
    "5": 0.5,
    "6": (ROWS * COLS - 16) / (ROWS * COLS)
  }

  const MINECOUNT = Math.round(ROWS * COLS * (DIFF_OPTIONS[DIFFICULTY] ?? DIFF_OPTIONS["0"]));
  const MINESIZE = 16;

  const TOP_SIZE = 28;

  const gameCanvas = document.getElementById("game");
  gameCanvas.height = TOP_SIZE + (ROWS + 2) * MINESIZE;
  gameCanvas.width = (COLS + 1) * MINESIZE;

  const sprite = document.getElementById("sprite");
  const smilesprite = document.getElementById("smilesprite");
  const numbersprite = document.getElementById("numbersprite");

  const ctx = gameCanvas.getContext("2d");

  var gameBoard = [];
  var awaitingFirstMove = true;
  var fault = "";
  var cellsLeft = 1;
  var minesLeft = MINECOUNT;
  var gameWon = false;
  var startTime = 0;
  var runningTime = 0;

  function populateBoard(skipMines) {
    awaitingFirstMove = true;
    gameBoard = [];
    fault = "";
    gameWon = false;
    minesLeft = MINECOUNT;
    startTime = Date.now();
    runningTime = Date.now();

    for(var r = 0; r < ROWS; r++) {
      gameBoard.push([]);
      for(var c = 0; c < COLS; c++) {
        gameBoard[r].push({
          open: false,
          count: 0,
          mine: false,
          exp: false,
          flag: false,
          lastInteracted: 0,
          username: ""
        });
      }
    }

    if(skipMines) return;

    cellsLeft = ROWS * COLS - MINECOUNT;

    for(var i = 0; i < MINECOUNT; i++) {
      const r = Math.floor(Math.random() * ROWS);
      const c = Math.floor(Math.random() * COLS);

      if(!gameBoard[r][c].mine) {
        gameBoard[r][c].mine = true;
        for(var lr = Math.max(0, r - 1); lr < Math.min(ROWS, r + 2); lr++) {
          for(var lc = Math.max(0, c - 1); lc < Math.min(COLS, c + 2); lc++) {
            gameBoard[lr][lc].count++;
          }
        }
      } else i--;
    }
  }

  function openSquare(x, y, username) {
    const gb = gameBoard[y][x]
    if(gb.mine) {
      fault = username;
      gb.exp = true;

      for(var r = 0; r < ROWS; r++) {
        for(var c = 0; c < COLS; c++) {
          if(gameBoard[r][c].mine || gameBoard[r][c].flag)
            gameBoard[r][c].open = true;
        }
      }

      const exp = document.createElement("VIDEO");
      exp.src = "explosion.webm";
      exp.className = "explosion";
      exp.muted = true;
      exp.playsinline = true;
      exp.autoplay = true;
      document.body.appendChild(exp);
      exp.play();
      setTimeout(() => {
        document.body.removeChild(exp);
      }, 1700);

      setTimeout(populateBoard, 5000);
    } else {
      gb.open = true;
      gb.lastInteracted = 1;
      gb.username = username;
      cellsLeft--;

      let didWin = false;

      if(gb.count == 0) {
        for(var lr = Math.max(0, y - 1); lr < Math.min(ROWS, y + 2); lr++) {
          for(var lc = Math.max(0, x - 1); lc < Math.min(COLS, x + 2); lc++) {
            if(!gameBoard[lr][lc].open) {
              didWin |= openSquare(lc, lr, "");
            }
          }
        }
      }

      if(cellsLeft <= 0) {
        return true;
      }

      return didWin;
    }
  }

  populateBoard(true);

  var awaitingPong = false;
  setInterval(() => {
    if(awaitingPong) {
      socket = new WebSocket("wss://irc-ws.chat.twitch.tv/");

      socket.addEventListener("open", e => {
        socket.send("CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership");
        socket.send("PASS SCHMOOPIIE");
        socket.send("NICK justinfan18858");
      });
    }

    socket.send("PING");
    awaitingPong = true;
  }, 10000);

  socket.addEventListener("open", e => {
    socket.send("CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership");
    socket.send("PASS SCHMOOPIIE");
    socket.send("NICK justinfan18858");
  });

  socket.addEventListener("message", e => {
    if(e.data.match(/^:tmi.twitch.tv 001 justinfan18858 :Welcome, GLHF!/)) {
      socket.send("JOIN #" + params.get("c"));
    }

    if(gameWon) return;

    const username = (e.data.match(/display-name=([^;]+)/) ?? [])[1];

    const mineCommand = e.data.match(/!mine\s*(\d+),\s*(\d+)/);

    if(mineCommand) {
      const x = parseInt(mineCommand[1]) - 1, y = parseInt(mineCommand[2]) - 1;

      console.log(x, y);

      if(!isNaN(x) && !isNaN(y) && x >= 0 && x < COLS && y >= 0 && y < ROWS) {
        if(awaitingFirstMove) {
          do {
            populateBoard();
          } while((gameBoard[y][x].count != 0 && DIFFICULTY != "6") || gameBoard[y][x].mine);

          awaitingFirstMove = false;
        }

        if(openSquare(x, y, username)){
          fault = username;
          gameWon = true;

          const yip = document.createElement("VIDEO");
          yip.src = "yippee.webm";
          yip.className = "explosion";
          yip.muted = true;
          yip.playsinline = true;
          yip.autoplay = true;
          document.body.appendChild(yip);
          yip.play();
          setTimeout(() => {
            document.body.removeChild(yip);
          }, 1200);

          setTimeout(populateBoard, 5000);
        }
      }
    }

    const flagCommand = e.data.match(/!flag\s*(\d+),\s*(\d+)/);

    if(!awaitingFirstMove && flagCommand) {
      const x = parseInt(flagCommand[1]) - 1, y = parseInt(flagCommand[2]) - 1;

      console.log(x, y);

      if(!isNaN(x) && !isNaN(y) && x >= 0 && x < COLS && y >= 0 && y < ROWS) {
        const gb = gameBoard[y][x];
        if(!gb.open) {
          if(gb.flag) {
            gb.flag = false;
            minesLeft++;
          } else {
            gb.flag = true;
            minesLeft--;
          }
          gb.username = username;
          gb.lastInteracted = 1;
        }
      }
    }

    awaitingPong = false;
  });

  var lt = Date.now();
  function render() {
    requestAnimationFrame(render);

    var nt = Date.now();
    var warp = (nt - lt) / 16;
    lt = nt;

    if(fault.length == 0) runningTime = nt;

    ctx.fillStyle = "#c0c0c0";
    ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

    for(var r = 0; r < ROWS; r++) {
      for(var c = 0; c < COLS; c++) {
        const gb = gameBoard[r][c];
        let spriteVal = 0;
        if(gb.open) {
          if(gb.exp) {
            spriteVal = 3;
          } else if(gb.mine) {
            spriteVal = 5;
          } else if(gb.flag) {
            spriteVal = 4;
          } else {
            spriteVal = 15 - gb.count;
          }
        } else if(gb.flag) {
          spriteVal = 1;
        }
        ctx.drawImage(sprite, 0, spriteVal * MINESIZE, MINESIZE, MINESIZE, (c + 1) * MINESIZE, TOP_SIZE + (r + 1) * MINESIZE, MINESIZE, MINESIZE);

        if(gb.lastInteracted > 0) {
          ctx.globalAlpha = gb.lastInteracted;

          ctx.fillStyle = "#0f0";
          ctx.fillRect((c + 1) * MINESIZE, TOP_SIZE + (r + 1) * MINESIZE, MINESIZE, MINESIZE);

          ctx.globalAlpha = 1;
        }
      }
    }

    ctx.drawImage(smilesprite,
      0, (fault.length == 0 ? 4 : gameWon ? 1 : 2) * 24,
      24, 24,
      gameCanvas.width / 2 - 12, TOP_SIZE / 2 - 12,
      24, 24
    );

    const nLookup = "- 9876543210";
    const mString = (minesLeft + "").padStart(3, " ").substr(-3);

    for(var i = 0; i < mString.length; i++) {
      ctx.drawImage(numbersprite, 0, nLookup.indexOf(mString[i]) * 23, 13, 23, 2 + 13 * i, 2, 13, 23);
    }

    const tString = (Math.floor((runningTime - startTime) / 1000) + "").padStart(3, " ").substr(-3);

    for(var i = 0; i < tString.length; i++) {
      ctx.drawImage(numbersprite, 0, nLookup.indexOf(tString[i]) * 23, 13, 23, gameCanvas.width + 13 * (i - 3) - 2, 2, 13, 23);
    }

    ctx.font = "12px monospace";
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for(var r = 0; r < ROWS; r++) {
      ctx.drawImage(sprite, 0, 15 * MINESIZE, MINESIZE, MINESIZE, 0, TOP_SIZE + (r + 1) * MINESIZE, MINESIZE, MINESIZE);
      ctx.fillText(r + 1, 0.5 * MINESIZE, TOP_SIZE + (r + 1.5) * MINESIZE);
    }
    for(var c = 0; c < COLS; c++) {
      ctx.drawImage(sprite, 0, 15 * MINESIZE, MINESIZE, MINESIZE, (c + 1) * MINESIZE, TOP_SIZE, MINESIZE, MINESIZE);
      ctx.fillText(c + 1, (c + 1.5) * MINESIZE, TOP_SIZE + 0.5 * MINESIZE);
    }
    ctx.fillText("!mine x,y  !flag x,y", gameCanvas.width / 2, TOP_SIZE + (ROWS + 1.5) * MINESIZE);

    for(var r = 0; r < ROWS; r++) {
      for(var c = 0; c < COLS; c++) {
        const gb = gameBoard[r][c];

        if(gb.lastInteracted > 0) {
          ctx.globalAlpha = gb.lastInteracted;

          ctx.fillStyle = "black";
          ctx.fillText(gb.username, (c + 1.5) * MINESIZE, TOP_SIZE + (r + 1.5) * MINESIZE);

          gb.lastInteracted -= warp * 0.01;
          ctx.globalAlpha = 1;
        }
      }
    }

    ctx.font = "24px monospace";
    if(fault.length > 0) {
      ctx.fillStyle = gameWon ? "#0f0" : "red";
      const width = ctx.measureText(fault).width;
      ctx.fillRect(gameCanvas.width / 2 - width / 2, gameCanvas.height / 2 - 15, width, 30);
      ctx.fillStyle = "black";
      ctx.fillText(fault, gameCanvas.width / 2, gameCanvas.height / 2);
    }
  }

  render();
</script>
